using pqytparser.Interfaces;
using pqytparser.Models;
using pqytparser.Resources;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace pqytparser.ViewModels
{
    public class VideoInfoParser : IVideoInfoParser
    {
        IVideoInfoDomDecoder _decoder;

        public VideoInfoParser()
        {
            _decoder = new VideoInfoDomDecoder();
        }

        public async Task<VideoDownloadInfo> GetContentUriAsync(string contentId, string contentTitle, IList<MimeTypeEnum> mimeTypes, IList<FileTypeEnum> fileTypes)
        {
            // Check for unknown mime and file types.
            if ((mimeTypes?.Count ?? 0) < 1 || mimeTypes.Contains(MimeTypeEnum.Unknown))
            {
                mimeTypes.Clear();
                mimeTypes.Add(MimeTypeEnum.Audio);
                mimeTypes.Add(MimeTypeEnum.MuxedAudioVideo);
            }

            if ((fileTypes?.Count ?? 0) < 1 || fileTypes.Contains(FileTypeEnum.Unknown))
            {
                fileTypes.Clear();
                fileTypes.Add(FileTypeEnum.M4a);
                fileTypes.Add(FileTypeEnum.Mp4);
                fileTypes.Add(FileTypeEnum.Webm);
            }

            // Decode and parse.
            string dom = await _decoder.GetVideoInfoDomAsync(contentId);
            VideoDownloadInfo info = _decoder.GetVideoDownloadInfo(contentId, contentTitle, dom);

            // Validate by assigning a rank to the 'mimeTypes' and 'fileTypes' that were passed in.
            // When 'IVideoInfoDomDecoder.GetVideoDownloadInfo.Videos.Count' does not equal or exceed the generated rank, the urls are thrown away.
            if (info.Availability == VideoAvailabilityEnum.Available && (info.Videos?.Count ?? 0) > 0)
            {
                int rank = ItagRank.GenerateRank(mimeTypes, fileTypes);
                if (info.Videos.Count < rank)
                    info = new VideoDownloadInfo(
                        VideoAvailabilityEnum.NotAvailable,
                        contentId,
                        contentTitle,
                        "Desired file types were not found.",
                        null);
            }

            return info;
        }


        static class ItagRank
        {
            const int _mp4Video = 1;
            const int _m4aAudio = 1;
            const int _mp4AudioVideo = 1;

            const int _gggpVideo = 0;
            const int _gggpAudio = 0;
            const int _gggpAudioVideo = 1;

            const int _flvVideo = 0;
            const int _flvAudio = 0;
            const int _flvAudioVideo = 1;

            const int _webmVideo = 1;
            const int _webmAudio = 1;
            const int _webmAudioVideo = 1;


            // Parses through the inputs 'mimeTypes' and 'fileTypes' to return an integer that represents both lists.
            // The integer returned by this method can be compared to the amount of download urls generated by 'IVideoInfoDomDecoder.GetVideoDownloadInfo' to determine that the list contains the desired mime and file types.
            // This is a hack solution that deals with the volatility of 'IVideoInfoDomDecoder.GetVideoInfoDomAsync'.
            public static int GenerateRank (IList<MimeTypeEnum> mimeTypes, IList<FileTypeEnum> fileTypes)
            {
                int rank = 0;
                if (fileTypes.Contains(FileTypeEnum.Flv))
                {
                    if (mimeTypes.Contains(MimeTypeEnum.Audio))
                        rank += _flvAudio;
                    if (mimeTypes.Contains(MimeTypeEnum.Video) || mimeTypes.Contains(MimeTypeEnum.Video3d))
                        rank += _flvVideo;
                    if (mimeTypes.Contains(MimeTypeEnum.MuxedAudioVideo) || mimeTypes.Contains(MimeTypeEnum.MuxedAudioVideo3d))
                        rank += _flvAudioVideo;
                }

                if (fileTypes.Contains(FileTypeEnum.Gggp))
                {
                    if (mimeTypes.Contains(MimeTypeEnum.Audio))
                        rank += _gggpAudio;
                    if (mimeTypes.Contains(MimeTypeEnum.Video) || mimeTypes.Contains(MimeTypeEnum.Video3d))
                        rank += _gggpVideo;
                    if (mimeTypes.Contains(MimeTypeEnum.MuxedAudioVideo) || mimeTypes.Contains(MimeTypeEnum.MuxedAudioVideo3d))
                        rank += _gggpAudioVideo;
                }

                if (fileTypes.Contains(FileTypeEnum.Mp4))
                {
                    if (mimeTypes.Contains(MimeTypeEnum.Video) || mimeTypes.Contains(MimeTypeEnum.Video3d))
                        rank += _mp4Video;
                    if (mimeTypes.Contains(MimeTypeEnum.MuxedAudioVideo) || mimeTypes.Contains(MimeTypeEnum.MuxedAudioVideo3d))
                        rank += _mp4AudioVideo;
                }

                if (fileTypes.Contains(FileTypeEnum.M4a))
                {
                    if (mimeTypes.Contains(MimeTypeEnum.Audio))
                        rank += _m4aAudio;
                }

                if (fileTypes.Contains(FileTypeEnum.Webm))
                {
                    if (mimeTypes.Contains(MimeTypeEnum.Audio))
                        rank += _webmAudio;
                    if (mimeTypes.Contains(MimeTypeEnum.Video) || mimeTypes.Contains(MimeTypeEnum.Video3d))
                        rank += _webmVideo;
                    if (mimeTypes.Contains(MimeTypeEnum.MuxedAudioVideo) || mimeTypes.Contains(MimeTypeEnum.MuxedAudioVideo3d))
                        rank += _webmAudioVideo;
                }

                return rank;
            }
        }
    }
}
